
https://www.terraform.io/


Executable written in golang
  - terraform file holds infrastructure build
    - can be split between several files for modularity
  - terraform state file (created when running terraform)
  - terraform preferences

# define credentials using variables
ex.
  variable "aws_access_key" {}
  variable "aws_secret_key" {}

# aws called provider, credentials defined there

provider "aws" {
  access_key = "access_key"
  secret_key = "secret_key"
  region = "us-east-1"
}

# server, etc called resource
#  resource details can be hard-coded or set via variables

resource "aws_instance" "ex" {
  ami = "ami-c58c1dd3"
  instance_type = "t2.micro"
}

# get info from deployment

output "aws_public_ip" {
  value = "${aws_instance.ex.public_dns}"
}


## Breakdown of a Sample terraform file
## START OF FILE

##################################################################################
# VARIABLES
# MAP NOTE:  set variables  for  Access / Secret / Private (.pem) Keys and path
##################################################################################

variable "aws_access_key" {}
variable "aws_secret_key" {}
variable "private_key_path" {}
variable "key_name" {
  default = "PluralsightKeys"
}

##################################################################################
# PROVIDERS
# MAP NOTE:  set the provider i.e. AWS
##################################################################################

provider "aws" {
  access_key = "${var.aws_access_key}"
  secret_key = "${var.aws_secret_key}"
  region     = "us-east-1"
}

##################################################################################
# RESOURCES
# MAP NOTE:  set resource to create (i.e. ec2 t2.micro instance)
#              - amazon machine image
#              - instance type
#              - key name
#            set the connection and private key path (user / private key)
#            set the provisioner (how / what to install)
##################################################################################

resource "aws_instance" "nginx" {
  ami           = "ami-c58c1dd3"
  instance_type = "t2.micro"
  key_name        = "${var.key_name}"

  connection {
    user        = "ec2-user"
    private_key = "${file(var.private_key_path)}"
  }

  provisioner "remote-exec" {
    inline = [
      "sudo yum install nginx -y",
      "sudo service nginx start"
    ]
  }
}

##################################################################################
# OUTPUT
# MAP NOTE:  capture specific output output (i.e. DNS)
##################################################################################

output "aws_instance_public_dns" {
    value = "${aws_instance.nginx.public_dns}"
}

## END OF FILE

NOTE: The above file is located in scratch/moduleone.tf

## Steps to run terraform and create AWS instances
##

## 1. Run terraform plan (from scratch directory)
##
## NOTE: terraform.tfvars holds key variable settings
scratch/> terraform plan -var-file=../vars/terraform.tfvars

## NOTE: below is the output generated stating what terraform plan would do

Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.


------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  + aws_instance.nginx
      id:                           <computed>
      ami:                          "ami-c58c1dd3"
      associate_public_ip_address:  <computed>
      availability_zone:            <computed>
      ebs_block_device.#:           <computed>
      ephemeral_block_device.#:     <computed>
      get_password_data:            "false"
      instance_state:               <computed>
      instance_type:                "t2.micro"
      ipv6_address_count:           <computed>
      ipv6_addresses.#:             <computed>
      key_name:                     "Terraform_key.pem"
      network_interface.#:          <computed>
      network_interface_id:         <computed>
      password_data:                <computed>
      placement_group:              <computed>
      primary_network_interface_id: <computed>
      private_dns:                  <computed>
      private_ip:                   <computed>
      public_dns:                   <computed>
      public_ip:                    <computed>
      root_block_device.#:          <computed>
      security_groups.#:            <computed>
      source_dest_check:            "true"
      subnet_id:                    <computed>
      tenancy:                      <computed>
      volume_tags.%:                <computed>
      vpc_security_group_ids.#:     <computed>


Plan: 1 to add, 0 to change, 0 to destroy.

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.




## 2. Apply the terraform plan
##
scratch/> terraform apply -var-file=../vars/terraform.tfvars
## NOTE: below is the output generated stating what terraform apply did
##       A couple of things to note:
##        - First is the output at the bottom of the run, this is the DNS that
##          was requested and is the public dns name of the nginx instance that
##          was spun up.
##               aws_instance_public_dns = ec2-75-101-179-144.compute-1.amazonaws.com
##
##        - There was an inital failure with the terraform apply, this issue was
##          an ssh timeout.  I had to update the inbound rules of the default
##          security group of the default vpc to allow traffic only from my IP
##          address.  Once this was done then the apply continued to success
##          NOTICE the bottom of the plan shows 1 to add and 1 to destroy.
##          Terraform destroyed the incomplete instance and then created a new one.
##          Plan: 1 to add, 0 to change, 1 to destroy.
##
## NOTE: changes are idempotent, which means if there is no change to configuration
##       then no changes would be done.




scratch/> terraform apply -var-file=../vars/terraform.tfvars
aws_instance.nginx: Refreshing state... (ID: i-0e31ebd11e8589a77)

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

-/+ aws_instance.nginx (tainted) (new resource required)
      id:                           "i-0e31ebd11e8589a77" => <computed> (forces new resource)
      ami:                          "ami-c58c1dd3" => "ami-c58c1dd3"
      associate_public_ip_address:  "true" => <computed>
      availability_zone:            "us-east-1d" => <computed>
      ebs_block_device.#:           "0" => <computed>
      ephemeral_block_device.#:     "0" => <computed>
      get_password_data:            "false" => "false"
      instance_state:               "running" => <computed>
      instance_type:                "t2.micro" => "t2.micro"
      ipv6_address_count:           "" => <computed>
      ipv6_addresses.#:             "0" => <computed>
      key_name:                     "Terraform_key" => "Terraform_key"
      network_interface.#:          "0" => <computed>
      network_interface_id:         "eni-2a261db3" => <computed>
      password_data:                "" => <computed>
      placement_group:              "" => <computed>
      primary_network_interface_id: "eni-2a261db3" => <computed>
      private_dns:                  "ip-172-31-28-28.ec2.internal" => <computed>
      private_ip:                   "172.31.28.28" => <computed>
      public_dns:                   "ec2-54-85-203-171.compute-1.amazonaws.com" => <computed>
      public_ip:                    "54.85.203.171" => <computed>
      root_block_device.#:          "1" => <computed>
      security_groups.#:            "1" => <computed>
      source_dest_check:            "true" => "true"
      subnet_id:                    "subnet-5469540d" => <computed>
      tenancy:                      "default" => <computed>
      volume_tags.%:                "0" => <computed>
      vpc_security_group_ids.#:     "1" => <computed>


Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

aws_instance.nginx: Destroying... (ID: i-0e31ebd11e8589a77)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 10s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 20s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 30s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 40s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 50s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0e31ebd11e8589a77, 1m0s elapsed)
aws_instance.nginx: Destruction complete after 1m1s
aws_instance.nginx: Creating...
  ami:                          "" => "ami-c58c1dd3"
  associate_public_ip_address:  "" => "<computed>"
  availability_zone:            "" => "<computed>"
  ebs_block_device.#:           "" => "<computed>"
  ephemeral_block_device.#:     "" => "<computed>"
  get_password_data:            "" => "false"
  instance_state:               "" => "<computed>"
  instance_type:                "" => "t2.micro"
  ipv6_address_count:           "" => "<computed>"
  ipv6_addresses.#:             "" => "<computed>"
  key_name:                     "" => "Terraform_key"
  network_interface.#:          "" => "<computed>"
  network_interface_id:         "" => "<computed>"
  password_data:                "" => "<computed>"
  placement_group:              "" => "<computed>"
  primary_network_interface_id: "" => "<computed>"
  private_dns:                  "" => "<computed>"
  private_ip:                   "" => "<computed>"
  public_dns:                   "" => "<computed>"
  public_ip:                    "" => "<computed>"
  root_block_device.#:          "" => "<computed>"
  security_groups.#:            "" => "<computed>"
  source_dest_check:            "" => "true"
  subnet_id:                    "" => "<computed>"
  tenancy:                      "" => "<computed>"
  volume_tags.%:                "" => "<computed>"
  vpc_security_group_ids.#:     "" => "<computed>"
aws_instance.nginx: Still creating... (10s elapsed)
aws_instance.nginx: Still creating... (20s elapsed)
aws_instance.nginx: Still creating... (30s elapsed)
aws_instance.nginx: Still creating... (40s elapsed)
aws_instance.nginx: Still creating... (50s elapsed)
aws_instance.nginx: Still creating... (1m0s elapsed)
aws_instance.nginx: Provisioning with 'remote-exec'...
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx: Still creating... (1m10s elapsed)
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx: Still creating... (1m20s elapsed)
aws_instance.nginx: Still creating... (1m30s elapsed)
aws_instance.nginx (remote-exec): Connecting to remote host via SSH...
aws_instance.nginx (remote-exec):   Host: 75.101.179.144
aws_instance.nginx (remote-exec):   User: ec2-user
aws_instance.nginx (remote-exec):   Password: false
aws_instance.nginx (remote-exec):   Private key: true
aws_instance.nginx (remote-exec):   SSH Agent: true
aws_instance.nginx (remote-exec):   Checking Host Key: false
aws_instance.nginx (remote-exec): Connected!
aws_instance.nginx (remote-exec): Loaded plugins: priorities, update-motd,
aws_instance.nginx (remote-exec):               : upgrade-helper
aws_instance.nginx (remote-exec): Resolving Dependencies
aws_instance.nginx (remote-exec): --> Running transaction check
aws_instance.nginx (remote-exec): ---> Package nginx.x86_64 1:1.12.1-1.33.amzn1 will be installed
aws_instance.nginx (remote-exec): --> Processing Dependency: libcrypto.so.10(OPENSSL_1.0.2)(64bit) for package: 1:nginx-1.12.1-1.33.amzn1.x86_64
aws_instance.nginx (remote-exec): --> Processing Dependency: libprofiler.so.0()(64bit) for package: 1:nginx-1.12.1-1.33.amzn1.x86_64
aws_instance.nginx (remote-exec): --> Running transaction check
aws_instance.nginx (remote-exec): ---> Package gperftools-libs.x86_64 0:2.0-11.5.amzn1 will be installed
aws_instance.nginx (remote-exec): --> Processing Dependency: libunwind.so.8()(64bit) for package: gperftools-libs-2.0-11.5.amzn1.x86_64
aws_instance.nginx (remote-exec): ---> Package openssl.x86_64 1:1.0.1k-15.99.amzn1 will be updated
aws_instance.nginx (remote-exec): ---> Package openssl.x86_64 1:1.0.2k-8.107.amzn1 will be an update
aws_instance.nginx (remote-exec): --> Running transaction check
aws_instance.nginx (remote-exec): ---> Package libunwind.x86_64 0:1.1-10.8.amzn1 will be installed
aws_instance.nginx (remote-exec): --> Finished Dependency Resolution

aws_instance.nginx (remote-exec): Dependencies Resolved

aws_instance.nginx (remote-exec): ========================================
aws_instance.nginx (remote-exec):  Package   Arch   Version
aws_instance.nginx (remote-exec):                      Repository    Size
aws_instance.nginx (remote-exec): ========================================
aws_instance.nginx (remote-exec): Installing:
aws_instance.nginx (remote-exec):  nginx     x86_64 1:1.12.1-1.33.amzn1
aws_instance.nginx (remote-exec):                      amzn-main    561 k
aws_instance.nginx (remote-exec): Installing for dependencies:
aws_instance.nginx (remote-exec):  gperftools-libs
aws_instance.nginx (remote-exec):            x86_64 2.0-11.5.amzn1
aws_instance.nginx (remote-exec):                      amzn-main    570 k
aws_instance.nginx (remote-exec):  libunwind x86_64 1.1-10.8.amzn1
aws_instance.nginx (remote-exec):                      amzn-main     72 k
aws_instance.nginx (remote-exec): Updating for dependencies:
aws_instance.nginx (remote-exec):  openssl   x86_64 1:1.0.2k-8.107.amzn1
aws_instance.nginx (remote-exec):                      amzn-updates 1.8 M

aws_instance.nginx (remote-exec): Transaction Summary
aws_instance.nginx (remote-exec): ========================================
aws_instance.nginx (remote-exec): Install  1 Package  (+2 Dependent packages)
aws_instance.nginx (remote-exec): Upgrade             ( 1 Dependent package)

aws_instance.nginx (remote-exec): Total download size: 2.9 M
aws_instance.nginx (remote-exec): Downloading packages:
aws_instance.nginx (remote-exec): (1/4): libunwind-1 |  72 kB   00:00
aws_instance.nginx (remote-exec): (3/4): nginx-1 15% | 474 kB   --:-- ETA
aws_instance.nginx (remote-exec): (2/4): gperftools- | 570 kB   00:00
aws_instance.nginx (remote-exec): (3/4): nginx-1.12. | 561 kB   00:00
aws_instance.nginx (remote-exec): (4/4): openssl 53% | 1.6 MB   00:01 ETA
aws_instance.nginx (remote-exec): (4/4): openssl-1.0 | 1.8 MB   00:00
aws_instance.nginx (remote-exec): ----------------------------------------
aws_instance.nginx (remote-exec): Total      2.7 MB/s | 2.9 MB  00:01
aws_instance.nginx (remote-exec): Running transaction check
aws_instance.nginx (remote-exec): Running transaction test
aws_instance.nginx (remote-exec): Transaction test succeeded
aws_instance.nginx (remote-exec): Running transaction
aws_instance.nginx (remote-exec):   Updating   : 1:openss [         ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [#        ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [##       ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [###      ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [####     ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [#####    ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [######   ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [#######  ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openss [######## ] 1/5
aws_instance.nginx (remote-exec):   Updating   : 1:openssl-1.0.2k-8   1/5
aws_instance.nginx (remote-exec):   Installing : libunwin [         ] 2/5
aws_instance.nginx (remote-exec):   Installing : libunwin [#####    ] 2/5
aws_instance.nginx (remote-exec):   Installing : libunwin [#######  ] 2/5
aws_instance.nginx (remote-exec):   Installing : libunwin [######## ] 2/5
aws_instance.nginx (remote-exec):   Installing : libunwind-1.1-10.8   2/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [         ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [#        ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [##       ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [###      ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [####     ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [#####    ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [######   ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [#######  ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftoo [######## ] 3/5
aws_instance.nginx (remote-exec):   Installing : gperftools-libs-2.   3/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [         ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [#        ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [##       ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [###      ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [####     ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [#####    ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [######   ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [#######  ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx- [######## ] 4/5
aws_instance.nginx (remote-exec):   Installing : 1:nginx-1.12.1-1.3   4/5
aws_instance.nginx (remote-exec):   Cleanup    : 1:openssl-1.0.1k-1   5/5
aws_instance.nginx (remote-exec):   Verifying  : libunwind-1.1-10.8   1/5
aws_instance.nginx (remote-exec):   Verifying  : gperftools-libs-2.   2/5
aws_instance.nginx (remote-exec):   Verifying  : 1:nginx-1.12.1-1.3   3/5
aws_instance.nginx (remote-exec):   Verifying  : 1:openssl-1.0.2k-8   4/5
aws_instance.nginx (remote-exec):   Verifying  : 1:openssl-1.0.1k-1   5/5

aws_instance.nginx (remote-exec): Installed:
aws_instance.nginx (remote-exec):   nginx.x86_64 1:1.12.1-1.33.amzn1

aws_instance.nginx (remote-exec): Dependency Installed:
aws_instance.nginx (remote-exec):   gperftools-libs.x86_64 0:2.0-11.5.amzn1
aws_instance.nginx (remote-exec):   libunwind.x86_64 0:1.1-10.8.amzn1

aws_instance.nginx (remote-exec): Dependency Updated:
aws_instance.nginx (remote-exec):   openssl.x86_64 1:1.0.2k-8.107.amzn1

aws_instance.nginx (remote-exec): Complete!
aws_instance.nginx (remote-exec): Starting nginx:          [  OK  ]
aws_instance.nginx: Creation complete after 1m37s (ID: i-0d37238bddb1e8776)

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.

Outputs:

aws_instance_public_dns = ec2-75-101-179-144.compute-1.amazonaws.com



## 3. Tear down the aws resources that were created via destroy
##
scratch/> terraform destroy -var-file=../vars/terraform.tfvars

aws_instance.nginx: Refreshing state... (ID: i-0d37238bddb1e8776)

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  - destroy

Terraform will perform the following actions:

  - aws_instance.nginx


Plan: 0 to add, 0 to change, 1 to destroy.

Do you really want to destroy?
  Terraform will destroy all your managed infrastructure, as shown above.
  There is no undo. Only 'yes' will be accepted to confirm.

  Enter a value: yes

aws_instance.nginx: Destroying... (ID: i-0d37238bddb1e8776)
aws_instance.nginx: Still destroying... (ID: i-0d37238bddb1e8776, 10s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0d37238bddb1e8776, 20s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0d37238bddb1e8776, 30s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0d37238bddb1e8776, 40s elapsed)
aws_instance.nginx: Still destroying... (ID: i-0d37238bddb1e8776, 50s elapsed)
aws_instance.nginx: Destruction complete after 54s

Destroy complete! Resources: 1 destroyed.

#######################################################################
## Terraform State
#######################################################################

Terraform keeps state in a json file: terraform.tfstate
  - contains resource mappings and metadata
    builds resource and dependency tree

  - When changes are being done to configuration, state file becomes locked so
    that only one person can make change to a resource at a time.

  - State file can be stored locally or remotely
      - remote storage of state files:
          - consul
          - aws s3

  - Can store state file to dev / prod files from same terraform file

Terraform Planning:
  - Terraform inspects state and can refresh from current state of resource
  - Terraform inspects configuration file
  - Creates dependency graph
      - what resources deployed
      - what order to deploy
      - creates dependency tree (subnets created after vpc created)
      - determines additions / deletions configuration change will make to
        the dependency graph
      - walks dependency graph and implements determined changes (adds / deletes)



## Terraform Data Sources
## Build a configuration with data outside of terraform
## NOTE: providers are responsible for defining data sources
##       data type is first  parm (aws_availability_zones)
##       data name is second parm (aws_availability_zones)

data "aws_availability_zones" "available" {}

## This sets up a data source by querying aws availability zones and returning the
## data to a variable called available

resource "aws_subnet" "subnet1" {
  cidr_block        = "${var.subnet1_address_space}"
  vpc_id            = "${aws_vpc.vpc.id}"
  availability_zone = "${data.aws_availability_zones.available.names[0]}"

}

This shows a subnet be declared as subnet1 and setting the availability_zone to
the data source declared earlier = ${data.aws_availability_zones.available.names[0]}


## create security group and elb using the created security group
##


# Nginx security group
resource "aws_security_group" "nginx-sg" {
  name        = "nginx_sg"
  vpc_id      = "${aws_vpc.vpc.id}"

  ingress {}
  egress {}
}

# elb based w/ sec grp created above
resource "aws_elb" "web" {
  name = "nginx-elb"
  security_groups = ["${aws_security_group.elb-sg.id}"]
}



#######################################################################
## More complicated example
#######################################################################

Here we will be creating an infrastructure that has:
  - a vpc
  - internet gateway
  - two subnets
  - route tables (and route table associations)
  - security groups
  - two web servers
  - an elb

This example is done in two parts (START, UPDATE).  Comments on what is happening
in each section will be done via NOTE:


### START
  ##################################################################################
  # VARIABLES
  # NOTE:  key variables delcared. Network address space declared for vpc and
  # NOTE:  the two subnets.
  ##################################################################################

  variable "aws_access_key" {}
  variable "aws_secret_key" {}
  variable "private_key_path" {}
  variable "key_name" {
    default = "PluralsightKeys"
  }
  variable "network_address_space" {
    default = "10.1.0.0/16"
  }
  variable "subnet1_address_space" {
    default = "10.1.0.0/24"
  }
  variable "subnet2_address_space" {
    default = "10.1.1.0/24"
  }

  ##################################################################################
  # PROVIDERS
  # NOTE:  Setting the provider for the resources and data.
  # NOTE:  Setting up w/ keys and region
  ##################################################################################

  provider "aws" {
    access_key = "${var.aws_access_key}"
    secret_key = "${var.aws_secret_key}"
    region     = "us-east-1"
  }

  ##################################################################################
  # DATA
  # NOTE:  Sets Data Type for available availability zones for region provided
  ##################################################################################

  data "aws_availability_zones" "available" {}

  ##################################################################################
  # RESOURCES
  ##################################################################################

  # NETWORKING #
  # NOTE:  Networking resources setup:
  # NOTE:  - vpc
  # NOTE:  - internet gateway
  # NOTE:  - subnet1 / subnet 2
  # NOTE:  - route table / route table association (link tbl to subnet)
  # NOTE:  - security group: setting ingress (22, 80) and egress (0) traffic
  #
  resource "aws_vpc" "vpc" {
    cidr_block = "${var.network_address_space}"
    enable_dns_hostnames = "true"

  }

  resource "aws_internet_gateway" "igw" {
    vpc_id = "${aws_vpc.vpc.id}"

  }

  resource "aws_subnet" "subnet1" {
    cidr_block        = "${var.subnet1_address_space}"
    vpc_id            = "${aws_vpc.vpc.id}"
    map_public_ip_on_launch = "true"
    availability_zone = "${data.aws_availability_zones.available.names[0]}"

  }

  resource "aws_subnet" "subnet2" {
    cidr_block        = "${var.subnet2_address_space}"
    vpc_id            = "${aws_vpc.vpc.id}"
    map_public_ip_on_launch = "true"
    availability_zone = "${data.aws_availability_zones.available.names[1]}"

  }

  # ROUTING #
  resource "aws_route_table" "rtb" {
    vpc_id = "${aws_vpc.vpc.id}"

    route {
      cidr_block = "0.0.0.0/0"
      gateway_id = "${aws_internet_gateway.igw.id}"
    }
  }

  resource "aws_route_table_association" "rta-subnet1" {
    subnet_id      = "${aws_subnet.subnet1.id}"
    route_table_id = "${aws_route_table.rtb.id}"
  }

  resource "aws_route_table_association" "rta-subnet2" {
    subnet_id      = "${aws_subnet.subnet2.id}"
    route_table_id = "${aws_route_table.rtb.id}"
  }

  # SECURITY GROUPS #
  # Nginx security group
  resource "aws_security_group" "nginx-sg" {
    name        = "nginx_sg"
    vpc_id      = "${aws_vpc.vpc.id}"

    # SSH access from anywhere
    ingress {
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }

    # HTTP access from anywhere
    ingress {
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }

    # outbound internet access
    egress {
      from_port   = 0
      to_port     = 0
      protocol    = "-1"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }

  # INSTANCES #
  # NOTE:  aws instance, set with type, subnet, sec group, key name
  # NOTE:  connection and a provisioner to install and set services and files
  #
  resource "aws_instance" "nginx1" {
    ami           = "ami-c58c1dd3"
    instance_type = "t2.micro"
    subnet_id     = "${aws_subnet.subnet1.id}"
    vpc_security_group_ids = ["${aws_security_group.nginx-sg.id}"]
    key_name        = "${var.key_name}"

    connection {
      user        = "ec2-user"
      private_key = "${file(var.private_key_path)}"
    }

    provisioner "remote-exec" {
      inline = [
        "sudo yum install nginx -y",
        "sudo service nginx start",
        "echo '<html><head><title>Blue Team Server</title></head><body style=\"background-color:#1F778D\"><p style=\"text-align: center;\"><span style=\"color:#FFFFFF;\"><span style=\"font-size:28px;\">Blue Team</span></span></p></body></html>' | sudo tee /usr/share/nginx/html/index.html"
      ]
    }
  }

  ##################################################################################
  # OUTPUT
  # NOTE:  get the public DNS name of the nginx instance
  ##################################################################################

  output "aws_instance_public_dns" {
      value = "${aws_instance.nginx1.public_dns}"
  }





## UPDATE
## NOTE:  Here are the differences between moduletwo-start.tf and
## NOTE:  moduletwo-update.tf.ignore
##

map@hexagon:/mod2/> diff moduletwo-start.tf moduletwo-update.tf.ignore  |  pg
44d43
## NOTE:  First thing to note is that the vpc loses the enable_dns_hostnames
## NOTE:  The thinking here is that with load blancer and iwg it is not needed.
<   enable_dns_hostnames = "true"
89a89,109
## NOTE:  Next thing that is created is a new security group for the elb.
> resource "aws_security_group" "elb-sg" {
>   name        = "nginx_elb_sg"
>   vpc_id      = "${aws_vpc.vpc.id}"
>
>   #Allow HTTP from anywhere
>   ingress {
>     from_port   = 80
>     to_port     = 80
>     protocol    = "tcp"
>     cidr_blocks = ["0.0.0.0/0"]
>   }
>
>   #allow all outbound
>   egress {
>     from_port   = 0
>     to_port     = 0
>     protocol    = "-1"
>     cidr_blocks = ["0.0.0.0/0"]
>   }
> }
>
103c123
## NOTE:  The nginx security group is then updated to have the HTTP ingress
## NOTE:  traffic only come from the network_address_space, hence only network
## NOTE:  traffic from the VPC (due to the igw and load balancer)
<   # HTTP access from anywhere
---
>   # HTTP access from the VPC
108c128
<     cidr_blocks = ["0.0.0.0/0"]
---
>     cidr_blocks = ["${var.network_address_space}"]
119a140,155
## NOTE:  Next a elb is created called nginx-elb.  This will be the load balancer
## NOTE:  for the two web servers.  The ports are set and the subnets are set to
## NOTE:  the two subnets.  The security group is set to the nginx_elb_sg and the
## NOTE:  instances point to the aws instances nginx1 and nginx2.
> # LOAD BALANCER #
> resource "aws_elb" "web" {
>   name = "nginx-elb"
>
>   subnets         = ["${aws_subnet.subnet1.id}", "${aws_subnet.subnet2.id}"]
>   security_groups = ["${aws_security_group.elb-sg.id}"]
>   instances       = ["${aws_instance.nginx1.id}", "${aws_instance.nginx2.id}"]
>
>   listener {
>     instance_port     = 80
>     instance_protocol = "http"
>     lb_port           = 80
>     lb_protocol       = "http"
>   }
> }
>
141a178,198
## NOTE:  Next to last a new web instance is created named nginx2. This uses
## NOTE:  subnet2 and the nginx-sg secuirty group.  It also provisions nginx,
## NOTE:  starts the sevices and updates the index.html
##
> resource "aws_instance" "nginx2" {
>   ami           = "ami-c58c1dd3"
>   instance_type = "t2.micro"
>   subnet_id     = "${aws_subnet.subnet2.id}"
>   vpc_security_group_ids = ["${aws_security_group.nginx-sg.id}"]
>   key_name        = "${var.key_name}"
>
>   connection {
>     user        = "ec2-user"
>     private_key = "${file(var.private_key_path)}"
>   }
>
>   provisioner "remote-exec" {
>     inline = [
>       "sudo yum install nginx -y",
>       "sudo service nginx start",
>       "echo '<html><head><title>Green Team Server</title></head><body style=\"background-color:#77A032\"><p style=\"text-align: center;\"><span style=\"color:#FFFFFF;\"><span style=\"font-size:28px;\">Green Team</span></span></p></body></html>' | sudo tee /usr/share/nginx/html/index.html"
>     ]
>   }
> }
>
146,147c203,204
## NOTE:  Lastly, the output is not the nginx1 public dns (remember the vpc
## NOTE:  value was updated to not allow it).  The output value is the
## NOTE:  is the elb public dns name.
##
< output "aws_instance_public_dns" {
<     value = "${aws_instance.nginx1.public_dns}"
---
> output "aws_elb_public_dns" {
>     value = "${aws_elb.web.dns_name}"



##################################################################################
## Configuring Resources After Creation
##################################################################################





##
